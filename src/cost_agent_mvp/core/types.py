"""Core data types and models for the cost agent."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import date, datetime
from typing import Any, Literal

from .constants import (
    Aggregation,
    ChartType,
    SortDirection,
    SourceType,
    TimeWindowType,
)

# -----------------------------
# Core planning / query contracts
# -----------------------------


@dataclass(frozen=True)
class TimeWindow:
    """
    Represents a time window request.
    - If type == YESTERDAY: start/end are computed later.
    - If type == LAST_N_DAYS: n_days must be provided.
    - If type == RANGE: start and end must be provided (inclusive start, inclusive end by convention).
    """

    type: TimeWindowType
    n_days: int | None = None
    start: date | None = None
    end: date | None = None


@dataclass(frozen=True)
class QueryFilters:
    """
    Filter conditions for data retrieval.
    Keep this conservative: only include fields we explicitly support.
    """

    account_id: list[int] | None = None
    chat_type: list[str] | None = None
    chat_id: list[str] | None = None

    has_tasks: bool | None = None
    has_classifications: bool | None = None
    has_both: bool | None = None


@dataclass(frozen=True)
class SortSpec:
    by: str
    direction: SortDirection = SortDirection.DESC


@dataclass(frozen=True)
class AggregationSpec:
    """
    Example:
      - field="total_cost", agg=SUM
      - field="account_id", agg=COUNT_DISTINCT
    """

    field: str
    agg: Aggregation
    as_name: str | None = None


@dataclass(frozen=True)
class QuerySpec:
    """
    A backend-agnostic query description that can be executed on CSV (now) or Postgres (later).
    """

    time_window: TimeWindow
    filters: QueryFilters = field(default_factory=QueryFilters)
    group_by: list[str] = field(default_factory=list)
    aggregations: list[AggregationSpec] = field(default_factory=list)
    sort: SortSpec | None = None
    top_n: int | None = None
    max_rows: int | None = None


@dataclass(frozen=True)
class Lineage:
    """
    Metadata describing how a table was produced (auditability & reproducibility).
    """

    source_type: SourceType
    dataset_name: str
    dataset_version: str  # e.g., CSV file hash or DB snapshot id
    generated_at_utc: datetime
    time_window: TimeWindow
    applied_filters: dict[str, Any]
    group_by: list[str]
    row_count: int
    notes: str | None = None


# -----------------------------
# Report templates & outputs
# -----------------------------


@dataclass(frozen=True)
class ChartSpec:
    """
    Declarative chart spec. In MVP you may only use a subset.
    """

    id: str
    type: ChartType
    table: str  # evidence table name
    title: str | None = None

    # generic fields to support common chart mappings
    x: str | None = None
    y: str | list[str] | None = None
    label: str | None = None
    value: str | None = None


@dataclass(frozen=True)
class ReportTemplate:
    """
    Loaded from report_templates.yaml.
    """

    template_id: str
    title: str
    description: str
    time_window: TimeWindow
    evidence_tables: list[str]
    charts: list[ChartSpec]
    constraints: dict[str, Any] = field(default_factory=dict)
    required_filters: list[str] = field(default_factory=list)


@dataclass(frozen=True)
class RunArtifacts:
    """
    Paths to output artifacts generated by a run.
    """

    run_id: str
    output_dir: str
    dashboard_png: str | None = None
    summary_txt: str | None = None
    evidence_dir: str | None = None
    run_record_json: str | None = None


@dataclass(frozen=True)
class RunRecord:
    """
    Saved to outputs/.../run_record.json for reproducibility and evaluation.
    """

    run_id: str
    started_at_utc: datetime
    finished_at_utc: datetime | None
    mode: Literal["button", "ad_hoc"]
    template_id: str | None
    user_input: str | None
    query_specs: list[QuerySpec]
    lineage: list[Lineage]
    artifacts: RunArtifacts
    verifier: dict[str, Any] = field(default_factory=dict)
    notes: dict[str, Any] = field(default_factory=dict)
